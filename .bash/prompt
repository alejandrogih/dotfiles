#!/usr/bin/env bash
# netj's bash module: prompt
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2002-07-18
# Requires: environment

bash_autoload=true

bash_import() {
    # ANSI color codes
    bash_default           red $'\E[0;31m'
    bash_default         green $'\E[0;32m'
    bash_default          blue $'\E[0;34m'
    bash_default          cyan $'\E[0;36m'
    bash_default       magenta $'\E[0;35m'
    bash_default        yellow $'\E[0;33m'
    bash_default         black $'\E[0;30m'
    bash_default          gray $'\E[0;37m'
    bash_default         white $'\E[0;38m'
    bash_default     light_red $'\E[1;31m'
    bash_default   light_green $'\E[1;32m'
    bash_default    light_blue $'\E[1;34m'
    bash_default    light_cyan $'\E[1;36m'
    bash_default light_magenta $'\E[1;35m'
    bash_default  light_yellow $'\E[1;33m'
    bash_default   light_white $'\E[1;37m'
    bash_default      no_color $'\E[0m'

    bash_default prompt_filler "----------------------------------------"
}

bash_load() {
    # a hack to measure how many columns given string takes
    prompt_takes_width() {
        local s=$1
        if [ ${BASH_VERSINFO[0]} -ge 3 ]; then
            # double the length of non-ASCII (perhaps wide) chars
            # FIXME: should filter all non-wide chars
            s="$s${s//[[:ascii:]]/}"
        fi
        echo ${#s}
    }

    # user part
    local user=${LOGNAME:-$USER}
    [ x"$user" != x"netj" ] || user=
    local user_plain=${user:+$user@}
    local user_part=${user:+"\[$blue\]$user\[$no_color\]@"}

    # date part
    local date_plain="`date '+%Y-%m-%d%a%T'`"
    local date_part="\D{$blue%Y-%m-%d$magenta%a}$light_yellow\t"
    if ! [ ${BASH_VERSINFO[0]} -gt 2 \
        -o ${BASH_VERSINFO[0]} == 2 -a ! "${BASH_VERSINFO[1]}" \< "05b" ]; then
        # prior to 2.05b, bash didn't handle custom date formats with \D{...}
        date_plain="DDD mmm dd HH:MM:SS"
        date_part="$blue\d $white\t"
    fi

    # sketch PS1
    local PS1_plain="($user_plain$hostnickname:""?0)--""(""&$date_plain)"
    prompt_min_width=`prompt_takes_width "$PS1_plain"`

    # prompt_flexible_part update codes
    prompt_fill_part=
    prompt_pwd_part=
    prompt_pwd=
    prompt_jobs_part=
    prompt_jobs=
    prompt_columns=
    prompt_update() {
        # gather some values
        local nrcolumns=${COLUMNS:-tput cols 2>/dev/null || true}
        local nrjobs=`jobs | wc -l`
        if ! [ "$prompt_pwd"        = "$PWD"        \
            -a "$prompt_jobs"       = "$nrjobs"     \
            -a "$prompt_columns"    = "$nrcolumns"  \
            ]; then
            # be lazy; work hard only when something changed
            prompt_columns=$nrcolumns
            prompt_pwd=$PWD
            prompt_jobs=$nrjobs
            local pwd=${PWD/#$HOME/\~}
            local changing="$pwd$nrjobs"
            local fillsize=$(($nrcolumns-$prompt_min_width-`prompt_takes_width "$changing"`))
            if [ $fillsize -lt 0 ]; then
                # terminal is too narrow :( try to trim pwd
                prompt_fill_part=
                local abbrev="**"
                local dir=${pwd%/*} name=/${pwd##*/}
                local room=$((${#pwd} + $fillsize))
                # check if there's room for basename
                local withname="$abbrev${dir:$((${#abbrev}-$fillsize))}$name"
                if [ ${#withname} -le $room ]; then
                    pwd=$withname
                    # check there's room for prefix
                    local prefix=${dir:2} # (the root part better than ~/ or /)
                    prefix="${dir:0:2}${prefix%%/*}$abbrev"
                    withprefix="$prefix${dir:$((${#prefix}-$fillsize))}$name"
                    if [ ${#withprefix} -le $room ]; then
                        pwd=$withprefix
                    fi
                fi
            elif [ $fillsize -ge 0 ]; then
                # terminal is wide enough, fill it up!
                while [ ${#prompt_fill_part} -lt $fillsize ]; do
                    prompt_fill_part="${prompt_fill_part:-$prompt_filler}$prompt_fill_part"
                done
                prompt_fill_part="${prompt_fill_part:0:$fillsize}"
            fi
            prompt_pwd_part=$pwd
            prompt_jobs_part=$nrjobs
        fi
    }
    # let prompt_update get regularly called by adding to $PROMPT_COMMAND
    bash_insert_prompt prompt_update

    # set window size dectection for $COLUMNS
    shopt -s checkwinsize

    # finally, replace PS1
    PS1="\
\[$no_color\](\
$user_part\
\[$red\]$hostnickname\[$no_color\]\
:\
\[$yellow\]"'$prompt_pwd_part'"\[$no_color\]\
?\[$cyan\]"'$?'"\[$no_color\]\
)"'$prompt_fill_part''${prompt_filler:0:$((3-${#?}))}'"(\
\[$green\]"'$prompt_jobs_part'"\[$no_color\]&\
$date_part\[$no_color\]\
)\n\\$ "
}

# vim:et:ts=8:sw=4:sts=4
